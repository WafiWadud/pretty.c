#+TITLE:libpretty: Making C Look ✨Pretty✨

The purpose of libpretty is to provide a programmer with a set of
macros to make C code much more readable. Inspired by Lua, Python,
JavaScript, and Lisp. Here's how a naive re-implementation of ~head~
utility might look like with libpretty:

#+begin_src C
  #include <stdio.h>
  #include "libpretty.h"

  int main (int argc, string argv[])
  {
      if (argc above 1)
          with (fclose, f, fopen(argv[1], "r"))
              fortimes (line, 10)
                  with (free, buf, vector(200, char, 0))
                      when (positive fscanf(f, "%s\n", buf))
                          then puts(buf)
                          otherwise 0;
      else
          puts("Please provide an input file");
      return EXIT_SUCCESS;
  }
#+end_src

The goals for the library are:
- Provide so much syntactic sugar as to cause any C developer a
  diabetes-induced heart attack.
- Deprecate Lua, Python, JavaScript, Ruby and a dozen other languages,
  because C+libpretty is the ultimate scripting language, but
  lightning-fast and strongly typed!
- Including only one header (yes, libpretty is a header-only library!)
  to turn any codebase into a beginner friendly one.

* Getting Started
Checkout the repository
#+begin_src sh
  git clone https://github.com/aartaka/libpretty
#+end_src

Or simply copy the ~libpretty.h~ file—libpretty is a header-only
library, so you can
#+begin_src C
  #include "libpretty.h"
#+end_src
from any file in the directory you drop ~libpretty.h~ to. Or from any
file really, if you specify the path to libpretty as an include (~-I~)
path.

* Provided Conveniences

** Included Standard Headers
- [[https://en.cppreference.com/w/c/types/boolean][stdbool.h]] :: for pretty booleans: ~true~ and ~bool~.
- [[https://en.cppreference.com/w/c/types/integer][stdint.h]] :: for fixed-width integer types like ~uint64_t~.
- [[https://en.cppreference.com/w/c/language/operator_alternative#Operator_macros.28C95.29][iso646.h]] :: for readable alternatives to regular operators,
  including ~and~ for ~&&~ and ~or~ for ~||~. Neat!

** Simple macros
Everyone defines these, so why not provide them?
- ~max~ and ~min~ of two numbers.
- ~len~ for array length.

** New types
Type aliases:
- ~string~ :: ~char*~.
- ~byte~ :: ~char~.
- ~bytes~ :: ~char*~.
- ~any~ :: ~void*~.

** New aliases
Mainly modeled after Lua and Lisp:
- ~eq~, because ~iso646.h~ only has ~not_eq~.
- ~bitnot~ and ~bitxor~ for operations that used to be called
  inconsistently (~compl~ and ~xor~ respectively) in ~iso646.h~.
- ~below~, ~above~, ~upto~, and ~downto~ comparison operators.
- ~nil~ for ~NULL~.
- ~until~ for negated ~while~.
- ~repeat~ from Lua as an alias for ~do~.
#+begin_src C
  int a = 10;
  repeat {
          printf("value of a: %i\n", a);
          a++;
  } until (a > 15);

  // Versus Lua:
  // a = 10
  // repeat
  //    print("value of a:", a)
  //    a = a + 1
  // until( a > 15 ) */
#+end_src
- ~begin~ and ~end~ block markers from BASIC, Ruby etc.
- ~always~, so that you can make infinite (event? server?) loops
#+begin_src C
  always printf("After all this time?\n");
#+end_src
- and ~never~ to comment out some code with just one keyword, while
  still allowing the compiler to analyze/optimize it (similar to
  [[https://clojuredocs.org/clojure.core/comment][Clojure ~comment~ form]]):
#+begin_src C
  never printf("This never runs, but never gets outdated, because compiler will shout at you if it does.\n");
#+end_src

** Pretty ternaries
Ternaries are frightening, so it won't hurt to add some plain
text. ~if~ and ~else~ are taken, but there are proper linguistic
alternatives that look quite Python/Lisp-like:
#+begin_src C
  return when some_condition
         then do_something()
         otherwise do_something_else();
#+end_src

It's ternaries underneath:
- ~when~ expands to empty string and is only provided for readability.
  - ~unless~ expands to ~not~ to be a negative version of ~when~.
- ~then~ expands to ~?~.
- ~otherwise~ expands to ~:~.

There's also ~only~ and ~notherwise~ for when the ~otherwise~ clause is
unnecessary:
#+begin_src C
  return when done()
         then 42 only;
#+end_src

** ~for~ Macros
These macros are aliases for certain ~for~ loop pattern, each
abstracting away some of the frequent ~for~ loop uses.

*** ~foreach (var, type, length, ...)~
This one walks an array or memory region initialized to the vararg
expression. Every time it iterates, ~var~ is set to a pointer to the
respective array element. Yes, pointer—so that you can modify the
element in place if you have to.
#+begin_src C
  foreach (i, int, 10, vector(10, int, 1, 2, 3, 3, 4, 5))
          printf("%i\n", *i);
#+end_src
Also shows the use of ~vector~.

*** ~forthese (var, type, ...)~
Iterates over the provided varargs, binding each of these to ~type~-d
~var~. The loop above can be translated as:
#+begin_src C
  forthese (i, int, 1, 2, 3, 3, 4, 5)
          printf("%i\n", i);
#+end_src

*** ~fortimes (var, times)~
A frequent case of going from 0 to some positive number. Saves you
quite some time for your
#+begin_src C
  for (int i = 0; i < 28; i++)
          printf("%i\n", i);
#+end_src

turning it into a simple
#+begin_src C
  fortimes (i, 28)
          printf("%i ", i+1);
  printf("\n28 stab wounds, you didn't want to leave him a chance, huh?\n");
#+end_src

~fortimes~ is implemented with...

*** ~forrange (var, init, target)~
Iterate over a range of numbers from ~init~ to
~target~. Pythonesque. Here's Celsius to Fahrenheit conversion loop
with ~forrange~:
#+begin_src C
  forrange (c, -10, 20)
          printf("Celsius %i = Fahrenheit %f\n", c, (32 + (c * 1.8)));
#+end_src

Note that ~init~ and ~target~ are arbitrary integers, signed and
unsigned. And ~init~ might be greater than ~target~.

~forrange~ is implemented with...

*** ~forrangeby (var, type, init, target, by)~
Iterate ~type~-d ~var~ from ~iter~ to ~target~, stepping by ~by~ every
time. Pythonesque.

#+begin_src C
  forrangeby (x, double, 1.0, 10.0, 0.5)
          printf("%f\n", x);
#+end_src

** Allocation macros
These allow quick-and-dirty allocation for typical patterns. Mostly
modeled after C++.

*** ~new (type, ...)~
C++ ~new~ operator is nice, so it won't hurt having something similar
in C, right? Ask no more:
#+begin_src C
  struct ListNode {
          int val;
          struct ListNode *next;
  };

  struct ListNode *node = new(struct ListNode, 2, new(struct ListNode, 1, nil));
#+end_src

Or, if you fancy, you can add even more syntax on top:
#+begin_src C
  #define cons(val, ...) new(struct ListNode, val, __VA_ARGS__)
  cons(2, cons(1, nil));
#+end_src

*** ~vector (length, type, ...)~
C++ again. ~std::vector~ is an extremely useful and versatile data
structure that's easy to reason about. While this macro is not even
remotely as featureful as C++ counterpart, it simplifies a frequent
pattern of "allocate an array of that much elements and with these
contents":
#+begin_src C
  double *vec = vector(10, double, 1, 2, 3, 4, 5);
#+end_src

** Block utilities
These establish new local bindings, ensure deferred computations, or
otherwise act on the block after them.

*** ~let (var, type, ...)~ and ~local~
Binds the ~type~-d ~var~ to the varargs for the duration of the next
block. Simulates JavaScript/Lisp ~let~. Also available as ~local~ with
the same functionality.

*** ~with (close, var, ...)~
This ensures that you never have use-after-free, because you provide
the freeing procedure (~close~) upfront. Especially useful for
dynamically allocated objects and file designators.
#+begin_src C
  with (fclose, file, fopen("hello.txt", "w"))
          fprintf(file, "Hello world!");
#+end_src

One of the downsides is that the bound ~var~ is a ~void *~, so you
might need to coerce it to your type before using it.

*** ~defer (...)~
Offloads the code to be executed after the following block. Not at the
end of function as in Go, because that's +impossible+ hard to
implement in C. Still, libpretty ~defer~ is useful enough.

*** ~try~ and ~catch~
Fancy error handling, now in C. Fancy example from [[https://en.cppreference.com/w/c/error/errno][errno reference]]:

#+begin_src C
  try log(0.0);
  catch (NOERR)
          printf("No error.\n");
  catch (EDOM, ERANGE)
          printf("Math error!\n");
#+end_src

~NOERR~ and ~NOERROR~ are also provided by libpretty, for convenience
of error switch-casing.
