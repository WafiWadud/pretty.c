#+TITLE:Lib Pretty—Making C Look ✨Pretty✨

The purpose of libpretty is to provide a programmer with a set of
macros to make C code much more readable. Inspired by Lua, Python,
JavaScript, and Lisp. Here's how the code might look like with
libpretty:

#+begin_src C

#+end_src


* Provided Conveniences

** Included Standard Headers
- Use of [[https://en.cppreference.com/w/c/types/boolean][stdbool.h]] for pretty boolean names, like ~true~ and ~bool~.
- [[https://en.cppreference.com/w/c/language/operator_alternative#Operator_macros.28C95.29][iso646.h]] inclusion. It provides readable alternatives to regular
  operators, including ~and~ for ~&&~ and ~or~ for ~||~. Neat!

** New aliases
Mainly modeled after Lua:
- ~eq~, because ~iso646.h~ only has ~not_eq~.
- ~bitnot~ and ~bitxor~ for operations that used to be called
  inconsistently (~compl~ and ~xor~ respectively) in ~iso646.h~.
- ~nil~ for ~NULL~.
- ~until~ for negated ~while~.
- ~repeat~ from Lua as an alias for ~do~.
#+begin_src C
  int a = 10;
  repeat {
          printf("value of a: %i\n", a);
          a++;
  } until (a > 15);

  // Versus Lua:
  // a = 10
  // repeat
  //    print("value of a:", a)
  //    a = a + 1
  // until( a > 15 ) */
#+end_src
- ~begin~ and ~end~ block markers from BASIC, Ruby etc.

** Pretty ternaries
Ternaries are frightening, so it won't hurt to add some plain
text. ~if~ and ~else~ are taken, but there are proper linguistic
alternatives that look quite Python/Lisp-like:
#+begin_src C
  return when some_condition
         then do_something()
         otherwise do_something_else();
#+end_src

It's ternaries underneath:
- ~when~ expands to empty string and is only provided for readability.
- ~then~ expands to ~?~.
- ~otherwise~ expands to ~:~.

There's also ~only~ and ~notherwise~ for when the ~otherwise~ clause is
unnecessary:
#+begin_src C
  return when done()
         then 42 only;
#+end_src


** ~for~ Macros
These macros are aliases for certain ~for~ loop pattern, each
abstracting away some of the frequent ~for~ loop uses.

*** ~foreach (var, type, length, ...)~
This one walks an array or memory region initialized to the vararg
expression. Every time it iterates, ~var~ is set to a pointer to the
respective array element. Yes, pointer—so that you can modify the
element in place if you have to.
#+begin_src C
  foreach(i, int, 10, vector(10, int, 1,2,3,3,4,5))
          printf("%i\n", *i);
#+end_src
Also shows the use of provided ~vector~ utility.

*** ~fortimes (var, times)~
A frequent case of going from 0 to some positive number. Saves you
quite some time for your
#+begin_src C
  for (int i = 0; i < 28; i++)
          printf("%i\n", i);
#+end_src

turning it into a simple
#+begin_src C
  fortimes (i, 28)
          printf("%i ", i+1);
  printf("\n28 stab wounds, you didn't want to leave him a chance, huh?\n");
#+end_src

Implemented with...

*** ~forrange (var, init, target)~
Iterate over a range of numbers from ~init~ to ~target~. Pythonesque.
#+begin_src C
  forrange(i, 0, 10)
          printf("%i\n", i);
  // Almost the same as Python:
  // for i in range(0, 10):
  //   print(i)
#+end_src

Note that ~init~ and ~target~ are arbitrary integers, signed and
unsigned. And ~init~ might be greater than ~target~.

Implemented with...

*** ~forrangeby (var, type, init, target, by)~

Iterate ~type~-d ~var~ from ~iter~ to ~target~, stepping by ~by~ every
time. Pythonesque.

#+begin_src C
  forrangeby(x, double, 1.0, 10.0, 0.5)
          printf("%f\n", x);
#+end_src

** Allocation macros
These allow quick-and-dirty allocation for typical patterns. Mostly
modeled after C++.

*** ~new (type, ...)~
C++ ~new~ operator is nice, so it won't hurt having something similar
in C, right? Ask no more:
#+begin_src C
  struct ListNode {
          int val;
          struct ListNode *next;
  };

  struct ListNode *node = new(struct ListNode, 2, new(struct ListNode, 1, nil));
#+end_src

Or, if you fancy, you can add even more syntax on top:
#+begin_src C
  #define cons(val, ...) new(struct ListNode, val, __VA_ARGS__)
  cons(2, cons(1, nil));
#+end_src

*** ~vector (length, type, ...)~
C++ again. ~std::vector~ is an extremely useful and versatile data
structure that's easy to reason about. While this macro is not even
remotely as featureful as C++ counterpart, it simplifies a frequent
pattern of "allocate an array of that much elements and with these
contents":
#+begin_src C
  double *vec = vector(10, double, 1, 2, 3, 4, 5);
  // Same as:
  // double vec[10] = {1, 2, 3, 4, 5};
  // But allocates the array on the heap.
#+end_src

** Block utilities
Most of these are wrappers around ~for~ (which proven itself quite a
versatile tool for this library. So they can use ~break~ to jump out
of the block. But they mostly serve a special purpose, so it makes no
sense ~break~-ing out.

*** ~once~
Runs the following block strictly once.

*** ~block (name)~
Sets up a ~goto~-able label and runs the following block. You can
~break~ out of it.

*** ~with (close, var, ...)~
This ensures that you never have use-after-free, because you provide
the freeing procedure upfront.
#+begin_src C
  
#+end_src

One of the downsides is that the bound variable is a ~void *~, so you
need to coerce it to your type before using it.

*** ~try~ and ~catch~
Fancy error handling, now in C. Compatible with ~errno~ and is
actually a wrapper around ~switch~ on ~errno~. Repurposing the example
from [[https://en.cppreference.com/w/c/error/errno][errno reference]]:

#+begin_src C
  try {
          log(0.0);
  } catch {
          case NOERR:
                  printf("No error.\n");
                  break;
          case EDOM:
                  printf("Domain error!\n");
                  break;
          case ERANGE:
                  printf("Range error!\n");
                  break;
  }
#+end_src

** Go-inspired utilities
Golang has several nice operations that are worth creatively
stealing. Mainly due to its concurrency handling.

*** ~defer (...)~
Offloads the code to be executed after the following block. Not at the
end of function as in Go, because that's impossible to implement in
C. Still, libpretty ~defer~ is useful enough.

*** ~go (fn, arg)~
Allows creating a new routine (thread, actually) calling ~fn~ with
~arg~. Allows to quickly jot down some parallelized code without
working with clumsy ~thread.h~ functions.
