#+TITLE:Lib Pretty—Making C Look ✨Pretty✨

The purpose of libpretty is to provide a programmer with a set of
macros to make C code much more readable. Inspired by Python,
JavaScript, and Lisp. Here's how the code might look like with
libpretty:

#+begin_src C

#+end_src


* Provided Conveniences

** Included Standard Headers
- Use of [[https://en.cppreference.com/w/c/types/boolean][stdbool.h]] for pretty boolean handling, like ~true~ and
  ~bool~.
- [[https://en.cppreference.com/w/c/language/operator_alternative#Operator_macros.28C95.29][iso646.h]] inclusion. It provides readable alternatives to regular
  operators, including ~and~ for ~&&~ and ~or~ for ~||~. Neat!
** New aliases
Mainly modeled after Lua:
- ~eq~, because ~iso646.h~ only has ~not_eq~.
- ~bitnot~ and ~bitxor~ for operations that used to be called
  inconsistently (~compl~ and ~xor~ respectively) in ~iso646.h~.
- ~nil~ for ~NULL~.
- ~until~ for negated ~while~.
- ~repeat~ from Lua as an alias for ~do~.
- ~begin~ and ~end~ block markers.

** Pretty ternaries
Ternaries are frightening, so it won't hurt to add some plain
text. ~if~ and ~else~ are taken, but there are proper linguistic
alternatives that look quite Python/Lisp-like:
#+begin_src C
  return when some_condition
         then do_something()
         otherwise do_something_else();
#+end_src

It's ternaries underneath:
- ~when~ expands to empty and only provided for consistency.
- ~then~ expands to ~?~.
- ~otherwise~ expands to ~:~.

There's also ~notherwise~ for when the ~otherwise~ clause is
unnecessary:
#+begin_src C
  return when done()
         then 42 notherwise;
#+end_src


** ~for~ Macros
These macros are aliases for certain ~for~ loop pattern, each
abstracting away some of the frequent ~for~ loop uses.

*** ~foreach (type, var, length, ...)~
This one walks an array or memory region initialized to the vararg
expression. Every time it iterates, ~var~ is set to a pointer to the
respective array element. Yes, pointer—so that you can modify the
element in place if you have to.

*** ~fortimes (var, times)~
A frequent case of going from 0 to some positive number. Saves you
quite some time for your
#+begin_src C
  for (int i = 0; i < 8; i++)
          printf("%i\n", i);
#+end_src

turning it into a simple
#+begin_src C
  fortimes (i, 8)
          printf("%s\n", i);
#+end_src

Implemented with...

*** ~forrange (var, init, target)~
Iterate over a range of numbers from ~init~ to ~target~. Pythonesque.
#+begin_src C
  forrange(i, 0, 10)
          printf("%i\n", i);
  /* Almost the same as Python:
     for i in range(0, 10):
       print(i)
  ,*/
#+end_src

Note that ~init~ and ~target~ might be any integers, signed and
unsigned. And ~init~ might be greater than ~target~.

Implemented with...

*** ~forrangeby (type, var, init, target, by)~

Iterate ~type~-d ~var~ from ~iter~ to ~target~, stepping by ~by~ every
time. Pythonesque.

#+begin_src C
  forrangeby(double, x, 1.0, 10.0, 0.5)
          printf("%f\n", x);
#+end_src

** ~new~
C++ ~new~ operator is nice, so it won't hurt having something similar
in C, right? Ask no more:
#+begin_src C
  struct ListNode {
          int val;
          struct ListNode *next;
  };
  
  struct ListNode *node = new(struct ListNode, 2, new(struct ListNode, 1, nil));
#+end_src

** ~with~
This ensures that you never have use-after-free, because you provide
the freeing procedure upfront.
#+begin_src C
  
#+end_src

One of the downsides is that the bound variable is a ~void *~, so you
need to coerce it to your type before proper use.
