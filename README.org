#+TITLE:libpretty: Making C Look ✨Pretty✨

The purpose of libpretty is to provide a programmer with a set of
macros to make C code much more readable. Inspired by Lua, Python,
JavaScript, and Lisp. Here's how a naive re-implementation of ~head~
utility might look like with libpretty:

#+begin_src C
  int main (int argc, char **argv)
  begin
      if (argc above 1)
          with (fclose, f, fopen(argv[1], "r"))
              fortimes (line, 10)
                  with (free, buf, vector(200, char, 0))
                      when (fscanf(f, "%s\n", buf) above 0)
                          then puts(buf)
                          otherwise 0;
      else
          puts("Please provide an input file");
      return EXIT_SUCCESS;
  end
#+end_src

The goals for the library are:
- Provide so much syntactic sugar as to cause any C developer a
  diabetes-induced heart attack.
- Deprecate Lua, Python, JavaScript, Ruby and a dozen other languages,
  because C+libpretty is the ultimate scripting language, but
  lightning-fast and strongly typed!
- Including only one header (yes, libpretty is a header-only library!)
  to turn any codebase into a beginner friendly one.

* Getting Started
Checkout the repository
#+begin_src sh
  git clone https://github.com/aartaka/libpretty
#+end_src

Or simply copy the ~libpretty.h~ file—libpretty is a header-only
library, so you can
#+begin_src C
  #include "libpretty.h"
#+end_src
from any file in the directory you drop ~libpretty.h~ to. Or from any
file really, if you specify the path to libpretty as an include (~-I~)
path.

* Provided Conveniences

** Included Standard Headers
- [[https://en.cppreference.com/w/c/types/boolean][stdbool.h]] :: for pretty booleans: ~true~ and ~bool~.
- [[https://en.cppreference.com/w/c/language/operator_alternative#Operator_macros.28C95.29][iso646.h]] :: for readable alternatives to regular operators, including
  ~and~ for ~&&~ and ~or~ for ~||~. Neat!

** New aliases
Mainly modeled after Lua:
- ~eq~, because ~iso646.h~ only has ~not_eq~.
- ~bitnot~ and ~bitxor~ for operations that used to be called
  inconsistently (~compl~ and ~xor~ respectively) in ~iso646.h~.
- ~below~, ~above~, ~upto~, and ~downto~ comparison operators.
- ~nil~ for ~NULL~.
- ~until~ for negated ~while~.
- ~repeat~ from Lua as an alias for ~do~.
#+begin_src C
  int a = 10;
  repeat {
          printf("value of a: %i\n", a);
          a++;
  } until (a > 15);

  // Versus Lua:
  // a = 10
  // repeat
  //    print("value of a:", a)
  //    a = a + 1
  // until( a > 15 ) */
#+end_src
- ~begin~ and ~end~ block markers from BASIC, Ruby etc.

** Pretty ternaries
Ternaries are frightening, so it won't hurt to add some plain
text. ~if~ and ~else~ are taken, but there are proper linguistic
alternatives that look quite Python/Lisp-like:
#+begin_src C
  return when some_condition
         then do_something()
         otherwise do_something_else();
#+end_src

It's ternaries underneath:
- ~when~ expands to empty string and is only provided for readability.
- ~then~ expands to ~?~.
- ~otherwise~ expands to ~:~.

There's also ~only~ and ~notherwise~ for when the ~otherwise~ clause is
unnecessary:
#+begin_src C
  return when done()
         then 42 only;
#+end_src


** ~for~ Macros
These macros are aliases for certain ~for~ loop pattern, each
abstracting away some of the frequent ~for~ loop uses.

*** ~foreach (var, type, length, ...)~
This one walks an array or memory region initialized to the vararg
expression. Every time it iterates, ~var~ is set to a pointer to the
respective array element. Yes, pointer—so that you can modify the
element in place if you have to.
#+begin_src C
  foreach(i, int, 10, vector(10, int, 1, 2, 3, 3, 4, 5))
          printf("%i\n", *i);
#+end_src
Also shows the use of provided ~vector~ utility.

*** ~forthese (var, type, ...)~
Iterates over the provided varargs, binding each of these to ~type~-d
~var~. The loop above can be translated as:
#+begin_src C
  forthese(i, int, 1, 2, 3, 3, 4, 5)
          printf("%i\n", i);
#+end_src

*** ~fortimes (var, times)~
A frequent case of going from 0 to some positive number. Saves you
quite some time for your
#+begin_src C
  for (int i = 0; i < 28; i++)
          printf("%i\n", i);
#+end_src

turning it into a simple
#+begin_src C
  fortimes (i, 28)
          printf("%lli ", i+1); // i is long long for your convenience
  printf("\n28 stab wounds, you didn't want to leave him a chance, huh?\n");
#+end_src

~fortimes~ is implemented with...

*** ~forrange (var, init, target)~
Iterate over a range of numbers from ~init~ to ~target~. Pythonesque.
#+begin_src C
  forrange(i, 0, 10)
          printf("%i\n", i);
  // Almost the same as Python:
  // for i in range(0, 10):
  //   print(i)
#+end_src

Note that ~init~ and ~target~ are arbitrary integers, signed and
unsigned. And ~init~ might be greater than ~target~.

~forrange~ is implemented with...

*** ~forrangeby (var, type, init, target, by)~

Iterate ~type~-d ~var~ from ~iter~ to ~target~, stepping by ~by~ every
time. Pythonesque.

#+begin_src C
  forrangeby(x, double, 1.0, 10.0, 0.5)
          printf("%f\n", x);
#+end_src

** Allocation macros
These allow quick-and-dirty allocation for typical patterns. Mostly
modeled after C++.

*** ~new (type, ...)~
C++ ~new~ operator is nice, so it won't hurt having something similar
in C, right? Ask no more:
#+begin_src C
  struct ListNode {
          int val;
          struct ListNode *next;
  };

  struct ListNode *node = new(struct ListNode, 2, new(struct ListNode, 1, nil));
#+end_src

Or, if you fancy, you can add even more syntax on top:
#+begin_src C
  #define cons(val, ...) new(struct ListNode, val, __VA_ARGS__)
  cons(2, cons(1, nil));
#+end_src

*** ~vector (length, type, ...)~
C++ again. ~std::vector~ is an extremely useful and versatile data
structure that's easy to reason about. While this macro is not even
remotely as featureful as C++ counterpart, it simplifies a frequent
pattern of "allocate an array of that much elements and with these
contents":
#+begin_src C
  double *vec = vector(10, double, 1, 2, 3, 4, 5);
#+end_src

** Block utilities
Most of these are wrappers around ~for~ (which proven itself quite a
versatile tool for this library. So they can use ~break~ to jump out
of the block. But they mostly serve a special purpose, so it makes no
sense ~break~-ing out.

*** ~let (var, type, ...)~ and ~local~
Binds the ~type~-d ~var~ to the varargs for the duration of the next
block. Simulates JavaScript/Lisp ~let~. Also available as ~local~ with the same functionality.

*** ~with (close, var, ...)~
This ensures that you never have use-after-free, because you provide
the freeing procedure (~close~) upfront. Especially useful for
dynamically allocated objects and file designators.
#+begin_src C
  with (fclose, file, fopen("hello.txt", "w"))
          fprintf(file, "Hello world!");
#+end_src

One of the downsides is that the bound ~var~ is a ~void *~, so you
might need to coerce it to your type before using it.

*** ~try~ and ~catch~
Fancy error handling, now in C. Compatible with ~errno~ and is
actually a wrapper around ~switch~ on ~errno~. Repurposing the example
from [[https://en.cppreference.com/w/c/error/errno][errno reference]]:

#+begin_src C
  try {
          log(0.0);
  } catch {
          case NOERR:
                  printf("No error.\n");
                  break;
          case EDOM:
                  printf("Domain error!\n");
                  break;
          case ERANGE:
                  printf("Range error!\n");
                  break;
  }
#+end_src

~NOERR~ and ~NOERROR~ are also provided by libpretty, for convenience
of error switch-casing.

** Go-inspired utilities
Golang has several nice operations that are worth creatively
stealing. Mainly due to its concurrency handling.

*** ~defer (...)~
Offloads the code to be executed after the following block. Not at the
end of function as in Go, because that's impossible to implement in
C. Still, libpretty ~defer~ is useful enough.

*** ~go (fn, arg)~
Allows creating a new routine (thread, actually) calling ~fn~ with
~arg~. Allows to quickly jot down some parallelized code without
working with clumsy ~thread.h~ functions.

But, in case you want to work with clumsy ~thread.h~ functions, ~go~
returns a thread identifier that might be reused when necessary.
